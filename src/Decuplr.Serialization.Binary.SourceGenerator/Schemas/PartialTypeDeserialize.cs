using System;
using System.Collections.Generic;
using System.Linq;
using Decuplr.Serialization.Analyzer.BinaryFormat;
using Decuplr.Serialization.Binary.Templates.ParserSource;
using Microsoft.CodeAnalysis;

namespace Decuplr.Serialization.Binary.Schemas {

    internal class PartialTypeDeserialize : IDeserializeSolution {

        private INamedTypeSymbol TypeSymbol => TypeInfo.Type.TypeSymbol;
        private IReadOnlyList<MemberFormatInfo> Member => TypeInfo.Member;
        private readonly TypeFormatLayout TypeInfo;
        private readonly Compilation Compilation;
        private readonly IEnumerable<DependencyCollection> DependencyStructs;


        private string InheritStrings {
            get {
                if (TypeSymbol.TypeKind == TypeKind.Struct)
                    return ": this()";
                // If base type != null and the base type is binaryformat / binaryparser then we should inherit the constructor
                // if (TypeSymbol.BaseType != null)
                //  return ":base(parsers, span, out int readBytes)";
                return string.Empty;
            }
        }

        public PartialTypeDeserialize(Compilation compilation, TypeFormatLayout typeInfo, IEnumerable<DependencyCollection> dependencyStructs) {
            TypeInfo = typeInfo;
            Compilation = compilation;
            DependencyStructs = dependencyStructs;
        }

        public GeneratedSourceCode[] GetAdditionalFiles() {
            return new GeneratedSourceCode[] { ($"{TypeSymbol.Name}.Generated.PartialDeserialize.cs", CreatePartialClassConstructor()) };
        }

        public string GetDeserializeFunction(string tryDeserializeFunctionName, string deserializeFunctionName) {
            var builder = new CodeNodeBuilder();
            foreach (var dependencyStruct in DependencyStructs) {
                // "DeserializeResult TryCreateType(in ParserCollection parsers, ReadOnlySpan<byte> span, out int readBytes, out Symbol result)"
                builder.AddAttribute(CommonAttributes.Inline);
                builder.AddNode($"private static {nameof(DeserializeResult)} {tryDeserializeFunctionName}(in {dependencyStruct.StructName} parsers, ReadOnlySpan<byte> span, out int readBytes, out {TypeSymbol} result)", node => {
                    node.AddStatement($"result = new {TypeSymbol} (parsers, span, out readBytes, out var deserializeResult);");
                    node.AddStatement($"return deserializeResult");
                });

                // "DeserializeResult TryCreateType(in ParserCollection parsers, ref SequenceCursor<byte> span, out Symbol result)"
                builder.AddAttribute(CommonAttributes.Inline);
                builder.AddNode($"private static {nameof(DeserializeResult)} {tryDeserializeFunctionName}(in {dependencyStruct.StructName} parsers, ref SequenceCursor<byte> cursor, out {TypeSymbol} result)", node => {
                    node.AddStatement($"result = new {TypeSymbol} (parsers, ref cursor, out var deserializeResult)");
                    node.AddStatement($"return deserializeResult");
                });

                // "Symbol CreateType(in ParserCollection parsers, ReadOnlySpan<byte> span, out int readBytes)"
                builder.AddAttribute(CommonAttributes.Inline);
                builder.AddNode($"private static {TypeSymbol} {deserializeFunctionName}(in {dependencyStruct.StructName} parsers, ReadOnlySpan<byte> span, out int readBytes)", node => {
                    node.AddStatement($"return new {TypeSymbol} (parsers, span, out readBytes)");
                });

                // "Symbol CreateType(in ParserCollection parsers, ref SequenceCursor<byte> span)"
                builder.AddAttribute(CommonAttributes.Inline);
                builder.AddNode($"private static {TypeSymbol} {deserializeFunctionName}(in {dependencyStruct.StructName} parsers, ref SequenceCursor<byte> cursor)", node => {
                    node.AddStatement($"return new {TypeSymbol} (parsers, ref cursor)");
                });

            }
            return builder.ToString();
        }

        private string CreatePartialClassConstructor() {

            var builder = new CodeSnippetBuilder(TypeSymbol.ContainingNamespace.ToString());
            builder.Using("System");
            builder.Using("System.Text");
            builder.Using("System.ComponentModel");
            builder.Using("System.CodeDom.Compiler");
            builder.Using("System.Runtime.CompilerServices");
            builder.Using("Decuplr.Serialization");
            builder.Using("Decuplr.Serialization.Binary");
            builder.Using($"static Decuplr.Serialization.Binary.Internal.{Compilation.GetDefaultAssemblyEntryClass()}");

            builder.AddPlain("// This file is automatically generated by Decuplr.Serilization.Binary library");
            builder.AddPlain("// For more information, see https://decuplr.dev/serialization/binary");
            builder.AddPlain("");
            builder.AddPlain($"// Debug Info : Built by {nameof(PartialTypeDeserialize)}");

            // {public} {partial} {class/ struct} Name {
            builder.AddPartialClass(TypeSymbol, node => {

                foreach (var dependencyStruct in DependencyStructs) {

                    // TryDeserialize
                    // internal {Type} (in ParserCollection parsers, ReadOnlySpan<byte> span, out int readBytes, out DeserializeResult result)
                    node.AddAttribute(CommonAttributes.GeneratedCodeAttribute);
                    node.AddAttribute(CommonAttributes.HideFromEditor);
                    node.AddNode($"internal {TypeSymbol.Name} (in {dependencyStruct.StructName} parsers, ReadOnlySpan<byte> span, out int readBytes, out {nameof(DeserializeResult)} result) {InheritStrings}", node => {

                        node.AddStatement("readBytes = -1");
                        node.AddStatement("var originalSpanLength = span.Length");
                        node.AddStatement("var currentReadBytes = 0");

                        foreach (var member in Member) {
                            node.AddPlain($"// Deserialization of {member.Symbol.Name}");
                            node.AddNode($"if (!parsers.{dependencyStruct[member]}.Deserialize(this, span, out currentReadBytes, out var {member.Symbol.Name}_Value, out result)", node => {
                                node.AddStatement("return");
                            });
                            node.AddStatement($"{member.Symbol.Name} = {member.Symbol.Name}_Value");
                            node.AddStatement($"span = span.Slice(currentReadBytes)");
                        }

                        node.AddStatement("readBytes = originalSpanLength - span.Length");
                        // errr can be emitted?
                        node.AddStatement($"result = {nameof(DeserializeResult)}.Success");
                    });

                    // TryDeserialize
                    // internal {Type} (in ParserCollection parsers, ref SequenceCursor<byte> cursor, out DeserializeResult result)
                    node.AddAttribute(CommonAttributes.GeneratedCodeAttribute);
                    node.AddAttribute(CommonAttributes.HideFromEditor);
                    node.AddNode($"internal {TypeSymbol.Name} (in {dependencyStruct.StructName} parsers, ref SequenceCursor<byte> cursor, out {nameof(DeserializeResult)} result) {InheritStrings}", node => {

                        foreach (var member in Member) {
                            node.AddPlain($"// Deserialization of {member.Symbol.Name}");
                            node.AddNode($"if (!parsers.{dependencyStruct[member]}.Deserialize(this, ref cursor, out var {member.Symbol.Name}_Value, out result)", node => {
                                node.AddStatement("return");
                            });
                            node.AddStatement($"{member.Symbol.Name} = {member.Symbol.Name}_Value");
                        }

                        node.AddStatement($"result = {DeserializeResult.Success.ToDisplayString()}");
                    });

                    // Deserialize
                    // internal {Type} (in ParserCollection parsers, ReadOnlySpan<byte> span, out int readBytes)
                    node.AddAttribute(CommonAttributes.GeneratedCodeAttribute);
                    node.AddAttribute(CommonAttributes.HideFromEditor);
                    node.AddNode($"internal {TypeSymbol.Name} (in {dependencyStruct.StructName} parsers, ReadOnlySpan<byte> span, out int readBytes) {InheritStrings}", node => {
                        node.AddStatement("readBytes = -1");
                        node.AddStatement("var originalSpanLength = span.Length");
                        node.AddStatement("var currentReadBytes = 0");
                        foreach (var member in Member) {
                            node.AddPlain($"// Serialization of {member.Symbol.Name}");
                            node.AddStatement($"{member.Symbol.Name} = parsers.{dependencyStruct[member]}.Deserialize(this, span, out currentReadBytes)");
                            node.AddStatement($"span.Slice(currentReadBytes)");
                        }
                        node.AddStatement("readBytes = originalSpanLength - span.Length");
                    });

                    // Deserialize
                    // interanl {Type} (in ParserCollection parsers, ref SequenceCursor<byte> cursor)
                    node.AddAttribute(CommonAttributes.GeneratedCodeAttribute);
                    node.AddAttribute(CommonAttributes.HideFromEditor);
                    node.AddNode($"internal {TypeSymbol.Name} (in {dependencyStruct.StructName} parsers, ref SequenceCursor<byte> cursor)", node => {
                        foreach(var member in Member) {
                            // Side note, if we want to have some features that would skip certain field or do some checksums, it should be done here, instead of the dependency struct
                            node.AddPlain($"// Deserialization of {member.Symbol.Name}");
                            node.AddStatement($"{member.Symbol.Name} = parsers.{dependencyStruct[member]}.Deserialize(this, ref cursor)");
                        }
                    });
                }

                // In case this class has a default constructor we need to implicit specifiy it for it
                if (TypeSymbol.Constructors.Any(member => member.Parameters.IsDefaultOrEmpty) && TypeSymbol.TypeKind != TypeKind.Struct)
                    node.AddNode($"public {TypeSymbol.Name} () ", node => { });
            });
            return builder.ToString();
        }

    }

}
