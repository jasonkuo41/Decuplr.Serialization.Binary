using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;

namespace Decuplr.Serialization.Binary.SourceGenerator {
    internal partial class PartialClassBuilder {

        private readonly INamedTypeSymbol Symbol;
        private readonly IReadOnlyList<TypeLayout> Layouts;

        public PartialClassBuilder(INamedTypeSymbol symbol, IReadOnlyList<TypeLayout> layouts) {
            Symbol = symbol;
            Layouts = layouts;
        }

        internal static string DefaultSerializePoint(INamedTypeSymbol symbol) => $"___generated__no_invoke_{symbol.Name}_Serializer";

        private static void AddClassNode(CodeNodeBuilder node, INamedTypeSymbol symbol, Action<CodeNodeBuilder> nodeAction) {
            node.AddNode(symbol.DeclaredAccessibility, $"{(symbol.IsStatic ? "static" : null)} partial {symbol.TypeKind.ToString().ToLower()} {symbol.Name}", nodeAction);
        }

        private static void AddPartialClass(CodeSnippetBuilder builder, INamedTypeSymbol symbol, Action<CodeNodeBuilder> nodeBuilder) {
            Action<CodeNodeBuilder>? previousNode = null;
            var nestedTypes = symbol.GetContainingTypes().ToList();

            for (var i = nestedTypes.Count - 1; i > 0; --i) {
                var containSymbol = nestedTypes[i];
                // Force capture value, so we don't StackOverflow
                var rnode = previousNode;
                previousNode = node => node.AddNode(containSymbol.DeclaredAccessibility, $"partial {containSymbol.TypeKind.ToString().ToLower()} {containSymbol.Name}", rnode ?? nodeBuilder);
            }
            builder.AddNode(nestedTypes[0].DeclaredAccessibility, $"partial {nestedTypes[0].TypeKind.ToString().ToLower()} {nestedTypes[0].Name}", previousNode ?? nodeBuilder);
        }

        public string CreatePartialClass() {
            //if (typeLayout.Count == 0)
            //    return string.Empty;

            var builder = new CodeSnippetBuilder(Symbol.ContainingNamespace.ToString());
            builder.Using("System");
            builder.Using("System.ComponentModel");
            builder.Using("System.CodeDom.Compiler");
            builder.Using("Decuplr.Serialization");

            builder.AddPlain("// This file is automatically generated by Decuplr.Serilization.Binary library");
            builder.AddPlain("// For more information, see https://decuplr.dev/serialization/binary");
            //builder.AddAttribute($"[GeneratedCode (\"{Assembly.GetExecutingAssembly().GetName().Name}\", \"{Assembly.GetExecutingAssembly().GetName().Version}\")]");

            // {public} {partial} {class/ struct} Name {
            AddPartialClass(builder, Symbol, node => {

                node.AddAttribute("[EditorBrowsable(EditorBrowsableState.Never)]");
                node.AddNode($"private {Symbol.Name} (BinarySerializer serializer, ReadOnlySpan<byte> binary) {(Symbol.TypeKind == TypeKind.Struct ? ":this()" : null)}", node => {
                    node.AddStatement("");
                    // We need to throw exception when we see a property like this :
                    // public int Property => 123;
                });

                node.AddAttribute("[EditorBrowsable(EditorBrowsableState.Never)]");
                node.AddNode($"internal static {nameof(SerializeResult)} {DefaultSerializePoint(Symbol)} (BinarySerializer serializer, ReadOnlySpan<byte> binary)", node => {
                    // Maybe we should check size first?
                    node.AddStatement("Span<byte> data");
                    node.AddStatement("int size");
                    node.AddPlain("");
                    for (var i = 0; i < Layouts.Count; ++i) {

                        var layout = Layouts[i];
                        var localSymbolName = $"__{layout.TargetSymbol}";

                        // Declare "IStatement __statement;"
                        node.AddStatement($"{layout.TargetType} {localSymbolName}");

                        node.AddNode(node => {
                            // Get Parser
                            node.AddStatement($"var currentSerializer = serializer.GetNamespace({layout.OverrideParser?.ParserNamespace ?? ""})");
                            node.AddStatement($"var parser = serializer.GetSerializer<{layout.TargetType}>()");

                            // If we fail to serialize
                            node.AddStatement("var result = parser.TryGetBinaryLength(currentSerializer, binary, out var size))");
                            node.AddNode($"if (result != {nameof(SerializeResult)}.{nameof(SerializeResult.Success)} )",
                                node => node.AddStatement("return result"));

                            node.AddStatement("var data = binary.Slice(0, size)");
                            node.AddStatement($"result = parser.TrySerialize(currentSerializer, data, out {localSymbolName})");
                            node.AddNode($"if (result != {nameof(SerializeResult)}.{nameof(SerializeResult.Success)} )",
                                node => node.AddStatement("return result"));

                            // Assign binary to the remain binary so we can proceed with next block
                            node.AddStatement("binary = binary.Slice(size)");
                        });
                    }
                    // TODO : Finally invoke the constructor
                    // node.AddStatement("");
                    node.AddStatement("return SerializeResult.Success");

                });

            });
            return builder.ToString();
        }
    }
}
