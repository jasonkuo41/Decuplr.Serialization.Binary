using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using Decuplr.Serialization.Analyzer.BinaryFormat;
using Decuplr.Serialization.Binary.SourceGenerator.BinaryFormatSource;
using Microsoft.CodeAnalysis;

namespace Decuplr.Serialization.Binary.SourceGenerator {

    internal class PartialTypeDeserialize : IDeserializeSolution {

        private INamedTypeSymbol TypeSymbol => TypeInfo.Type.TypeSymbol;
        private IReadOnlyList<MemberFormatInfo> Member => TypeInfo.Member;
        private readonly TypeFormatLayout TypeInfo;

        public PartialTypeDeserialize(TypeFormatLayout typeInfo) {
            TypeInfo = typeInfo;
        }

        public GeneratedSourceCode[] GetAdditionalFiles() { 
             return new GeneratedSourceCode[] { ($"{TypeSymbol.Name}.Generated.PartialDeserialize.cs", CreatePartialClassConstructor()) };
        }

        public GeneratedFormatFunction GetDeserializeFunction() {
            var builder = new CodeNodeBuilder();
            builder.AddNode($"private static {TypeSymbol} CreateType({TypeInfo.GetTypeParserContructor()})", node => {
                node.AddStatement($"return new {TypeSymbol} ({TypeInfo.GetTypeParserContructorInvokeParams()});");
            });
            return new GeneratedFormatFunction("CreateType", builder.ToString());
        }

        private string CreatePartialClassConstructor() {
            
            var builder = new CodeSnippetBuilder(TypeSymbol.ContainingNamespace.ToString());
            builder.Using("System");
            builder.Using("System.ComponentModel");
            builder.Using("System.CodeDom.Compiler");
            builder.Using("Decuplr.Serialization");
            builder.Using("Decuplr.Serialization.Binary");

            builder.AddPlain("// This file is automatically generated by Decuplr.Serilization.Binary library");
            builder.AddPlain("// For more information, see https://decuplr.dev/serialization/binary");
            builder.AddPlain("");
            builder.AddPlain($"// Debug Info : Built by {nameof(PartialTypeDeserialize)}");

            // {public} {partial} {class/ struct} Name {
            builder.AddPartialClass(TypeSymbol, node => {

                node.AddAttribute($"[GeneratedCode (\"{Assembly.GetExecutingAssembly().GetName().Name}\", \"{Assembly.GetExecutingAssembly().GetName().Version}\")]");
                node.AddAttribute("[EditorBrowsable(EditorBrowsableState.Never)]");

                // This is used for non "TryDeserialize" version
                // Function Signature 
                // internal {Type} ({ParserList}, ReadOnlySpan<byte> span, out DeserializeResult result, out int readBytes) {
                //    
                // }
                //
                node.AddPlain("// This is for \"TryDeserialize\" verion");
                node.AddNode($"internal {TypeSymbol.Name} ({TypeInfo.GetTypeParserContructor()}, ReadOnlySpan<byte> span, out int readBytes, out {nameof(DeserializeResult)} result) {(TypeSymbol.TypeKind == TypeKind.Struct ? ":this()" : null)}", node => {

                    for (var i = 0; i < Member.Count; ++i) {
                        // force capture i by value
                        var current = i;
                        node.AddNode(node => {
                            var symbol = Member[current].Symbol;
                            node.AddPlain($"// Configure for argument {symbol.Name}");
                            node.AddStatement("var currentReadBytes = 0");
                            // Checks if the field is declared to have a fixed binary length
                            if (Member[current].ConstantLength.HasValue) {
                                node.AddStatement($"var localSpan = span.Slice(0, {Member[current].ConstantLength!.Value})");
                                node.AddStatement($"var result = TryDeserialize_{symbol.Name} (ReadOnlySpan<byte> providedSpan, out currentReadBytes, out {symbol.Name})");
                                // These two check if the result is either insufficient of faulted.
                                // Since this field is required to have a solid size, we rewrites InsufficientSize to "Faulted"
                                node.AddNode($"if (result  == DeserializeResult.{nameof(DeserializeResult.InsufficientSize)})", node => {
                                    node.AddStatement($"return  DeserializeResult.Faulted(\"Expected {symbol.Name} in {TypeSymbol} to have a constant size of {Member[current].ConstantLength!.Value} but was insufficient.\")");
                                });
                                node.AddNode($"if (result == DeserializeResult.{nameof(DeserializeResult.Faulted)}", node => {
                                    node.AddStatement("return result");
                                });
                            }
                            else {
                                // Here the field is not declared to have a fixed binary length, thus we only return faulty results back
                                node.AddStatement($"var result = TryDeserialize_{symbol.Name} (ReadOnlySpan<byte> providedSpan, out currentReadBytes, out {symbol.Name})");
                                node.AddNode($"if (result != DeserializeResult.{nameof(DeserializeResult.Success)})", node => {
                                    node.AddStatement("return result");
                                });
                            }
                            // After completing parsing the data we slice the span for next persons consumption
                            node.AddStatement("span = span.Slice(0, currentReadBytes)");

                            // Local function for the member to actual deserializing work
                            node.AddAttribute("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
                            node.AddNode($"DeserializeResult TryDeserialize_{symbol.Name} (ReadOnlySpan<byte> providedSpan, out int readBytes, out {Member[current].TypeSymbol} value)", node => { 
                                switch (Member[current].DecisionAnnotation) {
                                    case BitUnionAnnotation bitUnion:

                                        break;
                                    case FormatAsAnnotation formatAs:

                                        break;
                                    default:
                                        node.AddStatement($"return parser_{current}_0.TryDeserialize(providedSpan, out readBytes, out value)");
                                        break;
                                }
                            });
                        });
                    }
                });

                // In case this class has a default constructor we need to implicit specifiy it for it
                if (TypeSymbol.Constructors.Any(member => member.Parameters.IsDefaultOrEmpty) && TypeSymbol.TypeKind != TypeKind.Struct)
                    node.AddNode($"public {TypeSymbol.Name} () ", node => { });
            });
            return builder.ToString();
        }
    }

}
