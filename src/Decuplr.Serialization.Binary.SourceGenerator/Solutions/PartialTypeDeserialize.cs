using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Microsoft.CodeAnalysis;

namespace Decuplr.Serialization.Binary.SourceGenerator {

    // TODO : Check if a struct is empty, if it is then simply ignore it

    internal class PartialTypeDeserialize : IDeserializeSolution {

        private INamedTypeSymbol TypeSymbol => TypeInfo.TypeSymbol;
        private IReadOnlyList<MemberFormatInfo> Layouts => TypeInfo.Members;
        private readonly TypeFormatInfo TypeInfo;

        public PartialTypeDeserialize(TypeFormatInfo typeInfo) {
            TypeInfo = typeInfo;
        }

        public GeneratedSourceCode[] GetAdditionalFiles() { 
             return new GeneratedSourceCode[] { ($"{TypeInfo.TypeSymbol.Name}.Generated.PartialDeserialize.cs", CreatePartialClassConstructor()) };
        }

        public GeneratedFormatFunction GetDeserializeFunction() {
            var builder = new CodeNodeBuilder();
            builder.AddNode($"private static {TypeSymbol} CreateType({GetConstructorParameters()})", node => {
                node.AddStatement($"return new {TypeSymbol} ({GetConstructorInvokeParameters()});");
            });
            return new GeneratedFormatFunction("CreateType", builder.ToString());
        }

        private string GetConstructorParameters() => string.Join(",", TypeInfo.Members.Select(x => $"{x.MemberTypeSymbol} s_{x.MemberSymbol.Name}"));
        private string GetConstructorInvokeParameters() => string.Join("," , TypeInfo.Members.Select(x => $"s_{x.MemberSymbol.Name}"));

        private string CreatePartialClassConstructor() {
            
            var builder = new CodeSnippetBuilder(TypeSymbol.ContainingNamespace.ToString());
            builder.Using("System");
            builder.Using("System.ComponentModel");
            builder.Using("System.CodeDom.Compiler");
            builder.Using("Decuplr.Serialization");

            builder.AddPlain("// This file is automatically generated by Decuplr.Serilization.Binary library");
            builder.AddPlain("// For more information, see https://decuplr.dev/serialization/binary");
            builder.AddPlain("");
            builder.AddPlain($"// Debug Info : Built by {nameof(PartialTypeDeserialize)}");

            // {public} {partial} {class/ struct} Name {
            builder.AddPartialClass(TypeSymbol, node => {

                node.AddAttribute($"[GeneratedCode (\"{Assembly.GetExecutingAssembly().GetName().Name}\", \"{Assembly.GetExecutingAssembly().GetName().Version}\")]");
                node.AddAttribute("[EditorBrowsable(EditorBrowsableState.Never)]");
                node.AddNode($"internal {TypeSymbol.Name} ({GetConstructorParameters()}) {(TypeSymbol.TypeKind == TypeKind.Struct ? ":this()" : null)}", node => {
                    foreach(var member in TypeInfo.Members)
                        node.AddStatement($"{member.MemberSymbol.Name} = s_{member.MemberSymbol.Name}");
                });

            });
            return builder.ToString();
        }
    }

}
